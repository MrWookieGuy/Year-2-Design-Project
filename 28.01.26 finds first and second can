/* * INTERPLANETARY ROBOT - AUTONOMOUS MISSION V7 (Find Red Can)
 * * Hardware:
 * 1. MD25 Motor Driver (0x58)
 * 2. Left Sensor: 3/2 | Right Sensor: 9/8
 * 3. Status LED: 12
 * * Logic: Green Can -> Wall -> Turn 90 -> Search Red -> Grab Red -> Reverse
 */

#include <Wire.h>

// ==========================================
// 1. CONSTANTS & PINS
// ==========================================
#define MD25ADDRESS 0x58
#define SPEED1 (byte)0x00
#define SPEED2 0x01
#define ENCODERONE 0x02
#define ENCODERTWO 0x06
#define RESETENCODERS 0x10
#define MODESELECTOR 0xF

#define trigLeft 3
#define echoLeft 2
#define trigRight 9
#define echoRight 8
#define ledPin 12

const int STOP = 128;
const int BASE_SPEED = 15;
const int TURN_SPEED = 15;
const int SEARCH_SPEED = 15; // Slower speed for searching forward
const int SCAN_DIST = 120;
const int GRAB_DIST = 8;
const int WALL_TARGET_DIST = 5; 

// --- TUNING REQUIRED ---
const float TICKS_PER_MM = 1.0; 
const long TICKS_FOR_180 = 1150;  
const long TICKS_FOR_90 = TICKS_FOR_180 / 2; 

// ==========================================
// 2. GLOBAL VARIABLES
// ==========================================
enum RobotState {
  STATE_STARTUP,
  STATE_MOVE_TO_BOX,
  STATE_SWEEP,
  STATE_APPROACH,    
  STATE_INDICATE,     
  STATE_REVERSE_FROM_CAN, 
  STATE_STRAIGHTEN,
  STATE_TURN_180,        
  STATE_RETURN_TO_WALL, 
  STATE_TURN_90_CLOCKWISE,
  
  // --- NEW STATES FOR RED CAN ---
  STATE_RED_SEARCH,      // Drive forward looking for Red Can
  STATE_RED_APPROACH,    // Zero in on Red Can
  STATE_RED_INDICATE,    // Flash LED
  STATE_RED_REVERSE,     // Back off
  STATE_COMPLETE
};

RobotState currentState = STATE_STARTUP;

// Variables to track movement 
long moveStartEncoder = 0; 
long headingTarget = 0;

// ==========================================
// 3. SETUP
// ==========================================
void setup() {
  Serial.begin(9600);
  Wire.begin();
  
  pinMode(trigLeft, OUTPUT); pinMode(echoLeft, INPUT);
  pinMode(trigRight, OUTPUT); pinMode(echoRight, INPUT);
  pinMode(ledPin, OUTPUT);
  
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(MODESELECTOR);
  Wire.write(0); 
  Wire.endTransmission();
  
  resetHardwareEncoders();
  Serial.println("SYSTEM READY. HEADING SET TO 0.");
}

// ==========================================
// 4. MAIN LOOP
// ==========================================
void loop() {
  
  switch (currentState) {
    
    // --- PART 1: GREEN CAN ---
    case STATE_STARTUP:
      delay(2000); 
      resetHardwareEncoders(); 
      delay(100);
      Serial.println("State: MOVING TO BOX");
      enterState(STATE_MOVE_TO_BOX);
      break;

    case STATE_MOVE_TO_BOX:
      if (driveRelativeDistance(600, BASE_SPEED)) {
        Serial.println("State: SWEEPING");
        currentState = STATE_SWEEP; 
      }
      break;

    case STATE_SWEEP:
      set_speed(STOP - TURN_SPEED, STOP + TURN_SPEED); 
      if (checkForObject()) {
        set_speed(STOP, STOP);
        delay(500);
        Serial.println("State: APPROACHING GREEN");
        currentState = STATE_APPROACH;
      }
      break;

    case STATE_APPROACH:
      if (performDifferentialApproach()) {
        Serial.println("State: INDICATING GREEN");
        currentState = STATE_INDICATE;
      }
      break;

    case STATE_INDICATE:
      set_speed(STOP, STOP);
      digitalWrite(ledPin, HIGH);
      delay(2000); 
      digitalWrite(ledPin, LOW);
      Serial.println("State: REVERSING 20cm");
      enterState(STATE_REVERSE_FROM_CAN);
      break;

    case STATE_REVERSE_FROM_CAN:
      if (driveRelativeDistance(-200, BASE_SPEED)) {
         Serial.println("State: STRAIGHTENING TO ZERO");
         currentState = STATE_STRAIGHTEN;
      }
      break;

    case STATE_STRAIGHTEN:
      if (returnToZeroHeading()) {
         Serial.println("State: TURN 180 ANTICLOCKWISE");
         headingTarget = -TICKS_FOR_180; 
         currentState = STATE_TURN_180;
      }
      break;

    // --- PART 2: RESET TO WALL ---
    case STATE_TURN_180:
      if (performTurnToTarget(headingTarget)) {
         delay(500); 
         Serial.println("State: RETURNING TO WALL");
         currentState = STATE_RETURN_TO_WALL;
      }
      break;

    case STATE_RETURN_TO_WALL:
      set_speed(STOP + BASE_SPEED, STOP + BASE_SPEED);
      
      if (checkForWall(WALL_TARGET_DIST)) {
         set_speed(STOP, STOP);
         delay(500); 
         Serial.println("State: TURN 90 CLOCKWISE");
         headingTarget = headingTarget + TICKS_FOR_90;
         currentState = STATE_TURN_90_CLOCKWISE;
      }
      break;

    case STATE_TURN_90_CLOCKWISE:
      if (performTurnToTarget(headingTarget)) {
          delay(500);
          Serial.println("State: SEARCHING FOR RED CAN");
          enterState(STATE_RED_SEARCH);
      }
      break;

    // --- PART 3: RED CAN ---
    
    // NEW: Drive forward and look for object
    case STATE_RED_SEARCH:
       // Drive forward slowly
       set_speed(STOP + SEARCH_SPEED, STOP + SEARCH_SPEED);
       
       // If object found (and it's not the far wall, so check < 80cm maybe?)
       if (checkForObject()) {
          set_speed(STOP, STOP);
          delay(500);
          Serial.println("State: APPROACHING RED");
          currentState = STATE_RED_APPROACH;
       }
       // Safety: Stop if we hit the far wall (e.g. > 2 meters driven)
       // Add safety timeout or distance check here if needed
       break;

    // Reuse approach logic
    case STATE_RED_APPROACH:
      if (performDifferentialApproach()) {
        Serial.println("State: INDICATING RED");
        currentState = STATE_RED_INDICATE;
      }
      break;

    // Reuse indication logic
    case STATE_RED_INDICATE:
      set_speed(STOP, STOP);
      digitalWrite(ledPin, HIGH);
      delay(2000); 
      digitalWrite(ledPin, LOW);
      Serial.println("State: REVERSING FROM RED");
      enterState(STATE_RED_REVERSE);
      break;

    // Reuse reverse logic
    case STATE_RED_REVERSE:
      if (driveRelativeDistance(-200, BASE_SPEED)) {
         Serial.println("State: MISSION COMPLETE");
         currentState = STATE_COMPLETE;
      }
      break;

    case STATE_COMPLETE:
      set_speed(STOP, STOP);
      break;
  }
}

// ==========================================
// 5. HELPER FUNCTIONS
// ==========================================

void enterState(RobotState newState) {
  currentState = newState;
  moveStartEncoder = getAvgEncoder(); 
}

long getAvgEncoder() {
  return (getEncoder1() + getEncoder2()) / 2;
}

bool driveRelativeDistance(long targetMM, int speed) {
  long currentPos = getAvgEncoder();
  long distTraveled = currentPos - moveStartEncoder;
  long targetTicks = targetMM * TICKS_PER_MM;

  if (abs(distTraveled) < abs(targetTicks)) {
    if (targetMM > 0) set_speed(STOP + speed, STOP + speed);
    else set_speed(STOP - speed, STOP - speed);
    return false; 
  } else {
    set_speed(STOP, STOP);
    return true;
  }
}

bool returnToZeroHeading() {
  long heading = getEncoder1() - getEncoder2();
  if (abs(heading) < 10) { 
    set_speed(STOP, STOP);
    return true; 
  }
  int turnPower = abs(heading) / 4; 
  turnPower = constrain(turnPower, 15, 25); 
  if (heading < 0) set_speed(STOP + turnPower, STOP - turnPower); 
  else set_speed(STOP - turnPower, STOP + turnPower); 
  return false; 
}

bool performTurnToTarget(long target) {
  long currentHeading = getEncoder1() - getEncoder2();
  long error = currentHeading - target;

  if (abs(error) < 15) { 
    set_speed(STOP, STOP);
    return true;
  }
  int turnPower = abs(error) / 4;
  turnPower = constrain(turnPower, 15, 25);

  if (error > 0) {
    set_speed(STOP - turnPower, STOP + turnPower); 
  } else {
    set_speed(STOP + turnPower, STOP - turnPower);
  }
  return false;
}

bool checkForWall(int limitCM) {
  int dL = readSensor(trigLeft, echoLeft); delay(5);
  int dR = readSensor(trigRight, echoRight);
  if (dL == 0) dL = 999;
  if (dR == 0) dR = 999;
  if (dL <= limitCM || dR <= limitCM) return true;
  return false;
}

// ==========================================
// 6. HARDWARE HELPERS
// ==========================================

void resetHardwareEncoders() {
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(RESETENCODERS); Wire.write(0x20);
  Wire.endTransmission();
}

bool checkForObject() {
  int dL = readSensor(trigLeft, echoLeft); delay(10);
  int dR = readSensor(trigRight, echoRight);
  if ((dL > 1 && dL < SCAN_DIST) || (dR > 1 && dR < SCAN_DIST)) return true;
  return false;
}

bool performDifferentialApproach() {
  int dL = readSensor(trigLeft, echoLeft); delay(10);
  int dR = readSensor(trigRight, echoRight);
  if (dL == 0) dL = 999; 
  if (dR == 0) dR = 999;

  int closest = min(dL, dR);
  if (closest > 0 && closest <= GRAB_DIST) return true;

  int error = dL - dR; 
  int turnFactor = 0;
  if (abs(error) > 2 && abs(error) < 50) { 
     turnFactor = error * 1.5; 
     turnFactor = constrain(turnFactor, -30, 30); 
  }
  set_speed(STOP + (BASE_SPEED + turnFactor), STOP + (BASE_SPEED - turnFactor));
  return false;
}

int readSensor(int trig, int echo) {
  digitalWrite(trig, LOW); delayMicroseconds(2);
  digitalWrite(trig, HIGH); delayMicroseconds(10);
  digitalWrite(trig, LOW);
  long d = pulseIn(echo, HIGH, 25000);
  return (d == 0) ? 999 : d * 0.034 / 2;
}

void set_speed(int s1, int s2) {
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(SPEED1); Wire.write(constrain(s1, 0, 255));
  Wire.endTransmission();
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(SPEED2); Wire.write(constrain(s2, 0, 255));
  Wire.endTransmission();
}

long getEncoder1() {
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(ENCODERONE);
  Wire.endTransmission();
  Wire.requestFrom(MD25ADDRESS, 4);
  if (Wire.available() < 4) return 0;
  long pos = (long)Wire.read() << 24;
  pos += (long)Wire.read() << 16;
  pos += (long)Wire.read() << 8;
  pos += (long)Wire.read();
  return pos;
}

long getEncoder2() {
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(ENCODERTWO);
  Wire.endTransmission();
  Wire.requestFrom(MD25ADDRESS, 4);
  if (Wire.available() < 4) return 0;
  long pos = (long)Wire.read() << 24;
  pos += (long)Wire.read() << 16;
  pos += (long)Wire.read() << 8;
  pos += (long)Wire.read();
  return pos;
}
