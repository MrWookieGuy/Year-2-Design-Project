/* * INTERPLANETARY ROBOT - AUTONOMOUS MISSION V4 (WALL ALIGNMENT)
 * * Hardware:
 * 1. MD25 Motor Driver (0x58)
 * 2. Left Sensor: 3/2 | Right Sensor: 9/8
 * 3. Status LED: 12
 * * Logic: Approach -> Grab -> Reverse 20cm -> Straighten -> Turn 180 -> Return to Wall -> Align Parallel
 */

#include <Wire.h>

// ==========================================
// 1. CONSTANTS & PINS
// ==========================================
#define MD25ADDRESS 0x58
#define SPEED1 (byte)0x00
#define SPEED2 0x01
#define ENCODERONE 0x02
#define ENCODERTWO 0x06
#define RESETENCODERS 0x10
#define MODESELECTOR 0xF

#define trigLeft 3
#define echoLeft 2
#define trigRight 9
#define echoRight 8
#define ledPin 12

const int STOP = 128;
const int BASE_SPEED = 20;
const int TURN_SPEED = 15;
const int SCAN_DIST = 120;
const int GRAB_DIST = 8;

// UPDATED: Stop 10cm from wall as requested
const int WALL_STOP_DIST = 10; 

const float TICKS_PER_MM = 1.0; 

// ==========================================
// 2. GLOBAL VARIABLES
// ==========================================
long targetHeading = 0; // Stores our heading before we turn to grab

enum RobotState {
  STATE_STARTUP,
  STATE_MOVE_TO_BOX,
  STATE_SWEEP,
  STATE_APPROACH,     
  STATE_INDICATE,     
  STATE_REVERSE_FROM_CAN, 
  STATE_STRAIGHTEN,       
  STATE_TURN_180,         
  STATE_RETURN_TO_WALL,   
  STATE_ALIGN_PARALLEL,   // NEW: Rotates in place to align with wall
  STATE_COMPLETE
};

RobotState currentState = STATE_STARTUP;

// ==========================================
// 3. SETUP
// ==========================================
void setup() {
  Serial.begin(9600);
  Wire.begin();
  
  pinMode(trigLeft, OUTPUT); pinMode(echoLeft, INPUT);
  pinMode(trigRight, OUTPUT); pinMode(echoRight, INPUT);
  pinMode(ledPin, OUTPUT);
  
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(MODESELECTOR);
  Wire.write(0); // Mode 0: Independent Speed
  Wire.endTransmission();
  
  encoderReset();
  Serial.println("SYSTEM READY.");
}

// ==========================================
// 4. MAIN LOOP
// ==========================================
void loop() {
  
  switch (currentState) {
    
    case STATE_STARTUP:
      delay(2000); 
      encoderReset(); 
      delay(100);
      Serial.println("State: MOVING TO BOX");
      currentState = STATE_MOVE_TO_BOX;
      break;

    case STATE_MOVE_TO_BOX:
      if (driveDistance(600, BASE_SPEED)) {
        Serial.println("State: SWEEPING");
        currentState = STATE_SWEEP;
      }
      break;

    case STATE_SWEEP:
      set_speed(STOP - TURN_SPEED, STOP + TURN_SPEED);
      if (checkForObject()) {
        set_speed(STOP, STOP);
        delay(500);
        
        // Save Heading
        targetHeading = getEncoder1() - getEncoder2();
        Serial.print("Target Locked. Heading Ref: "); 
        Serial.println(targetHeading);
        
        Serial.println("State: APPROACHING");
        currentState = STATE_APPROACH;
      }
      break;

    case STATE_APPROACH:
      if (performDifferentialApproach()) {
        Serial.println("State: INDICATING");
        currentState = STATE_INDICATE;
      }
      break;

    case STATE_INDICATE:
      set_speed(STOP, STOP);
      digitalWrite(ledPin, HIGH);
      delay(2000); 
      digitalWrite(ledPin, LOW);
      
      Serial.println("State: REVERSING 20cm");
      currentState = STATE_REVERSE_FROM_CAN;
      break;

    case STATE_REVERSE_FROM_CAN:
      if (driveRelative(-200)) { 
         currentState = STATE_STRAIGHTEN;
      }
      break;

    case STATE_STRAIGHTEN:
      Serial.println("State: STRAIGHTENING");
      if (restoreHeading()) {
         delay(500);
         Serial.println("State: TURN 180");
         currentState = STATE_TURN_180;
      }
      break;

    case STATE_TURN_180:
      pivotTurn(450); // Check this value with your calibration!
      encoderReset(); 
      Serial.println("State: RETURNING TO WALL");
      currentState = STATE_RETURN_TO_WALL;
      break;

    case STATE_RETURN_TO_WALL:
      // Drive forward until 10cm from wall
      if (driveUntilWall()) {
        Serial.println("State: ALIGNING PARALLEL");
        currentState = STATE_ALIGN_PARALLEL;
      }
      break;

    // --- NEW ALIGNMENT STATE ---
    case STATE_ALIGN_PARALLEL:
      // Rotate in place until Left and Right sensors match
      if (performWallAlignment()) {
        Serial.println("State: MISSION COMPLETE");
        currentState = STATE_COMPLETE;
      }
      break;

    case STATE_COMPLETE:
      set_speed(STOP, STOP);
      break;
  }
}

// ==========================================
// 5. COMPLEX MOVEMENT FUNCTIONS
// ==========================================

bool performWallAlignment() {
  int dL = readSensor(trigLeft, echoLeft);
  delay(15); // Good delay to prevent cross-talk
  int dR = readSensor(trigRight, echoRight);
  
  // Safety: Filter Bad Readings
  if (dL > 200 || dR > 200 || dL == 0 || dR == 0) {
     set_speed(STOP, STOP);
     return false;
  }

  int diff = dL - dR;
  
  // Tolerance: 1 cm
  if (abs(diff) <= 1) {
    set_speed(STOP, STOP);
    return true; // Aligned!
  }
  
  // Rotate to fix angle
  // Gain (K) = 2. Speed min 10, max 25.
  int rotSpeed = abs(diff) * 2;
  rotSpeed = constrain(rotSpeed, 10, 25);
  
  if (diff > 0) {
    // Left is further away -> Robot facing Right -> Turn Left (CCW)
    set_speed(STOP - rotSpeed, STOP + rotSpeed);
  } else {
    // Right is further away -> Robot facing Left -> Turn Right (CW)
    set_speed(STOP + rotSpeed, STOP - rotSpeed);
  }
  
  return false;
}

bool driveRelative(long distMM) {
  static long startVal = 0;
  static bool initialized = false;
  
  if (!initialized) {
    startVal = getEncoder1();
    initialized = true;
  }
  
  long target = abs(distMM * TICKS_PER_MM);
  long driven = abs(getEncoder1() - startVal);
  
  if (driven < target) {
    set_speed(STOP - BASE_SPEED, STOP - BASE_SPEED); 
    return false;
  } else {
    set_speed(STOP, STOP);
    initialized = false; 
    return true;
  }
}

bool restoreHeading() {
  long currentHeading = getEncoder1() - getEncoder2();
  long error = currentHeading - targetHeading;
  
  if (abs(error) < 10) {
    set_speed(STOP, STOP);
    return true;
  }
  
  int rotSpeed = error * 1.5; 
  rotSpeed = constrain(rotSpeed, -30, 30);
  set_speed(STOP - rotSpeed, STOP + rotSpeed); 
  return false;
}

bool driveUntilWall() {
  // Check close enough to stop?
  int dL = readSensor(trigLeft, echoLeft);
  delay(10);
  int dR = readSensor(trigRight, echoRight);
  
  // Use the closest sensor to be safe (so we don't crash if angled)
  int dist = min(dL, dR);
  
  if (dist == 0 || dist > 200) dist = 999;
  
  if (dist <= WALL_STOP_DIST) {
    set_speed(STOP, STOP);
    return true;
  }
  
  set_speed(STOP + BASE_SPEED, STOP + BASE_SPEED);
  return false;
}

void pivotTurn(long ticks) {
  encoderReset();
  delay(50);
  while(abs(getEncoder1()) < ticks) {
    set_speed(STOP - TURN_SPEED, STOP + TURN_SPEED);
  }
  set_speed(STOP, STOP);
}

// ==========================================
// 6. STANDARD FUNCTIONS 
// ==========================================

bool driveDistance(long distanceMM, int speed) {
  long target = distanceMM * TICKS_PER_MM;
  if (abs(getEncoder1()) < target) {
    set_speed(STOP + speed, STOP + speed);
    return false;
  } else {
    set_speed(STOP, STOP);
    encoderReset();
    return true;
  }
}

bool checkForObject() {
  int dL = readSensor(trigLeft, echoLeft); delay(10);
  int dR = readSensor(trigRight, echoRight);
  if ((dL > 1 && dL < SCAN_DIST) || (dR > 1 && dR < SCAN_DIST)) return true;
  return false;
}

bool performDifferentialApproach() {
  int dL = readSensor(trigLeft, echoLeft); delay(10);
  int dR = readSensor(trigRight, echoRight);
  int closest = min(dL, dR);
  
  if (closest > 0 && closest <= GRAB_DIST) return true;

  int error = dL - dR; 
  int turnFactor = 0;
  
  if (abs(error) > 2 && abs(error) < 50) { 
     turnFactor = error * 1.5; 
     turnFactor = constrain(turnFactor, -30, 30); 
  }

  set_speed(STOP + (BASE_SPEED + turnFactor), STOP + (BASE_SPEED - turnFactor));
  return false;
}

int readSensor(int trig, int echo) {
  digitalWrite(trig, LOW); delayMicroseconds(2);
  digitalWrite(trig, HIGH); delayMicroseconds(10);
  digitalWrite(trig, LOW);
  long d = pulseIn(echo, HIGH, 25000);
  return (d == 0) ? 999 : d * 0.034 / 2;
}

void set_speed(int s1, int s2) {
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(SPEED1); Wire.write(constrain(s1, 0, 255));
  Wire.endTransmission();
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(SPEED2); Wire.write(constrain(s2, 0, 255));
  Wire.endTransmission();
}

void encoderReset() {
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(RESETENCODERS); Wire.write(0x20);
  Wire.endTransmission();
}

long getEncoder1() {
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(ENCODERONE);
  Wire.endTransmission();
  Wire.requestFrom(MD25ADDRESS, 4);
  if (Wire.available() < 4) return 0;
  long pos = (long)Wire.read() << 24;
  pos += (long)Wire.read() << 16;
  pos += (long)Wire.read() << 8;
  pos += (long)Wire.read();
  return pos;
}

long getEncoder2() {
  Wire.beginTransmission(MD25ADDRESS);
  Wire.write(ENCODERTWO);
  Wire.endTransmission();
  Wire.requestFrom(MD25ADDRESS, 4);
  if (Wire.available() < 4) return 0;
  long pos = (long)Wire.read() << 24;
  pos += (long)Wire.read() << 16;
  pos += (long)Wire.read() << 8;
  pos += (long)Wire.read();
  return pos;
}
